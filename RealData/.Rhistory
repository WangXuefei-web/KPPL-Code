library(ggplot2)
set.seed(123)
### 1. Load data and change the formate ###
mydata <- read.delim("E:/water/3.GAMLSS/meanvalue_date.txt")
mydata$date <- as.Date(mydata$date)
n <- length(mydata$date)
mydata['num'] <- c(1:n)
library (MASS)
library(gamlss)
library(gamlss.dist)
library(ggplot2)
set.seed(123)
mydata <- read.delim("E:/water/3.GAMLSS/meanvalue_date.txt")
mydata$date <- as.Date(mydata$date)
n <- length(mydata$date)
con <- gamlss.control(trace = FALSE)
m22 <- gamlss(value ~ poly(date, 2), sigma.fo = ~poly(date, 2), data = mydata, control = con)
# 4. Determine the best model
# con <- gamlss.control(trace = FALSE)
# m22 <- gamlss(value ~ poly(date, 2), sigma.fo = ~poly(date, 2), data = mydata, control = con)
summary(m22)
# Fitted plot
plot(value ~ date, data = mydata)
#lines(mydata$date, fitted(m2), col = "blue")
lines(mydata$date, fitted(m22), col = "red")
fittedPlot(m22, x=mydata$date, line.type=TRUE)
#Warm plot
wp(m22, xvar =mydata$date, n.inter = 4, cex = 0.3, pch = 20)
m22$mu.x
mu.fv
withouttrend <- mydata$value-m22$mu.fv
plot(withouttrend ~ mydata$date)
plot(withouttrend ~ mydata$date,type="l")
a=1
b=sqrt(2)
c=sqrt(3)
d=a+b+c
vec=c(a,b,c)/d
vec
setwd("F:/BaiduSyncdisk/Try - Penalized likelihood-based method for community detection with unknown number of communities/R_penalfig")
library(reshape2)
library(ggplot2)
library(plot3D)
library(RColorBrewer)
library(directlabels)
eps <- 1e-6
pi1 <- c(seq(0,0.1,0.0005),seq(0.11,0.2,0.01),seq(0.25,1,0.05))
pi2 <- c(seq(0,0.1,0.0005),seq(0.11,0.2,0.01),seq(0.25,1,0.05))
pi3 <- 1-pi1-pi2
grid12 <-expand.grid(list(pi1=pi1,pi2=pi2))
#field <- grid12$pi1+grid12$pi2<=1
# 1. 2D Plot
penal1 <- log(pi1+eps)-log(eps)
png("1pi2D.png", height=1000,width=800, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
penal1 <- log(pi1+eps)-log(eps)
png("1pi2D.png", height=900,width=800, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=600,width=500, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=900,width=800, res=196)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=700, res=196)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=700, res=190)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=700, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=750, res=182)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=750, res=190)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=750, res=185)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)))
dev.off()
png("1pi2D.png", height=800,width=750, res=185)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)),cex.axis=0.8,cex.lab=1.2)
dev.off()
png("1pi2D.png", height=800,width=750, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)),lwd=1.5,cex.axis=0.8,cex.lab=1.2)
dev.off()
penal <- log(grid12$pi1+eps)+log(grid12$pi2+eps)+log((1-grid12$pi1-grid12$pi2)+eps)-3*log(eps)
grid.penal <- matrix(penal,length(pi1),length(pi2))
colormap <- colorRampPalette(rev(brewer.pal(11,'Spectral')))(100)
persp3D(pi1,pi2,grid.penal,
theta = 30,phi=30,d=3,lwd=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.15),
xlab = '', ylab = '', zlab = '')
png("3pi3D.png", height=800,width=1200, res=168)
persp3D(pi1,pi2,grid.penal,
theta = 30,phi=30,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.15),
xlab = '', ylab = '', zlab = '')
# min(penal, na.rm=T)  13.81551
text3D(0.6, -0.4, 13.5, labels = expression(pi[1]), theta = 30, phi=30,add = TRUE, col ='black')
text3D(1.3, 0.3, 13.5, labels = expression(pi[2]), theta = 30, phi=30, add = TRUE, col ='black')
text3D(-1, -0.2, 22, labels = expression(sum(log*frac(epsilon+pi[k],epsilon),k==1,3)), theta = 30, phi=30, add = TRUE, col ='black')
dev.off()
persp3D(pi1,pi2,grid.penal,
theta = 20,phi=30,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.15),
xlab = '', ylab = '', zlab = '')
persp3D(pi1,pi2,grid.penal,
theta = 25,phi=20,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.15),
xlab = '', ylab = '', zlab = '')
persp3D(pi1,pi2,grid.penal,
theta = 30,phi=30,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.25,cex.clab = 0.8),
xlab = '', ylab = '', zlab = '')
persp3D(pi1,pi2,grid.penal,
theta = 30,phi=30,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.18,cex.clab = 0.8),
xlab = '', ylab = '', zlab = '')
png("3pi3D.png", height=800,width=1200, res=168)
persp3D(pi1,pi2,grid.penal,
theta = 30,phi=30,d=3,cex.axis=0.8,cex.lab=1.2,
col=colormap,scale=TRUE,border = NA,
bty='f',box=TRUE,ticktype='detailed',contour = TRUE,
xlim=c(-0.1,1.1),ylim=c(-0.1,1.1),colkey = list(length=0.5,width=1,dist=-0.18,cex.clab = 0.8),
xlab = '', ylab = '', zlab = '')
# min(penal, na.rm=T)  13.81551
text3D(0.6, -0.4, 13.5, labels = expression(pi[1]), theta = 30, phi=30,add = TRUE, col ='black')
text3D(1.3, 0.3, 13.5, labels = expression(pi[2]), theta = 30, phi=30, add = TRUE, col ='black')
text3D(-1, -0.2, 22, labels = expression(sum(log*frac(epsilon+pi[k],epsilon),k==1,3)), theta = 30, phi=30, add = TRUE, col ='black')
dev.off()
png("1pi2D.png", height=800,width=750, res=180)
plot(pi1,penal1,type='l',xlab = expression(pi[k]),ylab=expression(log(pi[k]+epsilon)-log(epsilon)),lwd=1.5,cex.axis=0.9,cex.lab=1.2)
dev.off()
# Real data
library(R.matlab)
library(Matrix)
library(MASS)
library(tidyverse)
library(ggplot2)
library(gtools)
library(igraph)
library(ggraph)
#library(qgraph)
library(colormap)
library(wesanderson)
source("../R_SBM/fun_SBM.R")
source("../R_DCSBM/fun_DCSBM.R")
setwd("F:/BaiduSyncdisk/Try - Penalized likelihood-based method for community detection with unknown number of communities/R_RealData")
# Real data
library(R.matlab)
library(Matrix)
library(MASS)
library(tidyverse)
library(ggplot2)
library(gtools)
library(igraph)
library(ggraph)
#library(qgraph)
library(colormap)
library(wesanderson)
source("../R_SBM/fun_SBM.R")
source("../R_DCSBM/fun_DCSBM.R")
# 2. Coauthor
CoauMat <- readMat('data/CoauAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
iconv(CoauMat$authorNames,to="UTF-8")
V(GCoau)$name <- iconv(CoauMat$authorNames,to="UTF-8",sub='')
vcount(GCoau) # 4383
ecount(GCoau) # 6056
Gd <- degree(GCoau)
mean(Gd) # 2.763404
sum(Gd<5) # 2869 # <= 3409 # sum(Gd>10)=107
# cores <- graph.coreness(GCoau)
V.id <- c(1:vcount(GCoau))
subV.id <- V.id[Gd>=3]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
Gd <- degree(GCoau)
degree(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
K.max <- 5
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
K.max <-3
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
source("../R_DCSBM/Competitors_DCSBM")
source("../R_DCSBM/Competitors_DCSBM.R")
ini.SCORE(CoauAdj,K.max)
# 2. Coauthor
CoauMat <- readMat('data/CiteeAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
# 2. Coauthor
CoauMat <- readMat('data/CiteeAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
CoauMat$authorNames
# 2. Coauthor
CoauMat <- readMat('data/CoauFinal.mat')
# 2. Coauthor
CoauMat <- readMat('data/CoauAdjFinal.mat')
authorName <- CoauMat$authorNames
CoauMat <- readMat('data/CiteeAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames<-authorName
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
iconv(CoauMat$authorNames,to="UTF-8")
V(GCoau)$name <- iconv(CoauMat$authorNames,to="UTF-8",sub='')
vcount(GCoau) # 4383
# 2. Coauthor
CoauMat <- readMat('data/CoauAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
iconv(CoauMat$authorNames,to="UTF-8")
V(GCoau)$name <- iconv(CoauMat$authorNames,to="UTF-8",sub='')
vcount(GCoau) # 4383
ecount(GCoau) # 6056
Gd <- degree(GCoau)
# cores <- graph.coreness(GCoau)
V.id <- c(1:vcount(GCoau))
subV.id <- V.id[Gd>=5]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max) ini.SCORE(CoauAdj,K.max)
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
source("../R_DCSBM/fun_DCSBM.R")
CoauMat <- readMat('data/CoauAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
iconv(CoauMat$authorNames,to="UTF-8")
V(GCoau)$name <- iconv(CoauMat$authorNames,to="UTF-8",sub='')
vcount(GCoau) # 4383
ecount(GCoau) # 6056
Gd <- degree(GCoau)
mean(Gd) # 2.763404
sum(Gd<5) # 2869 # <= 3409 # sum(Gd>10)=107
# cores <- graph.coreness(GCoau)
V.id <- c(1:vcount(GCoau))
subV.id <- V.id[Gd>=5]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max)
subV.id <- V.id[Gd>=3]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
Coau.Para.hat <- Est.DCSBM(CoauAdj,K.max,tun.c = 1)
ini.SCORE(CoauAdj,4)
table(ini.SCORE(CoauAdj,4))
table(ini.SCORE(CoauAdj,3))
subV.id <- V.id[Gd>3]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
table(ini.SCORE(CoauAdj,3))
CoauMat <- readMat('data/CoauAdjFinal.mat')
CoauAdj <- as.matrix(CoauMat$A)
GCoau <- graph.adjacency(CoauAdj, mode="undirected")
CoauMat$authorNames <- apply(CoauMat$authorNames,1,function(x) x[[1]][[1]])
iconv(CoauMat$authorNames,to="UTF-8")
V(GCoau)$name <- iconv(CoauMat$authorNames,to="UTF-8",sub='')
vcount(GCoau) # 4383
ecount(GCoau) # 6056
Gd <- degree(GCoau)
mean(Gd) # 2.763404
sum(Gd<5) # 2869 # <= 3409 # sum(Gd>10)=107
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
subV.id <- V.id[Gd>1]
# cores <- graph.coreness(GCoau)
V.id <- c(1:vcount(GCoau))
subV.id <- V.id[Gd>1]
GCoau.core <- induced_subgraph(GCoau, subV.id)
vcount(GCoau.core) # 1514
# induced a connected subgraph
comps <- decompose.graph(GCoau.core)
table(sapply(comps,vcount)) # the biggest connected graph has 1408 vertices
GCoau.dense <- comps[[1]]
vcount(GCoau.dense)
CoauAdj <- get.adjacency(GCoau.dense)
K.max <- 10
table(ini.SCORE(CoauAdj,3))
setwd("F:/BaiduSyncdisk/Try - Penalized likelihood-based method for community detection with unknown number of communities/R_RealData")
# Real data
library(R.matlab)
library(Matrix)
library(MASS)
library(tidyverse)
library(ggplot2)
library(gtools)
library(igraph)
library(ggraph)
#library(qgraph)
library(colormap)
library(wesanderson)
source("../R_SBM/fun_SBM.R")
source("../R_DCSBM/fun_DCSBM.R")
source("../R_DCSBM/Competitors_DCSBM.R")
# 1. Trade
#Read Edge Data from Trade.csv file
trade <- read.csv("data/Trade.csv", header = TRUE)
year <- 15
trade <- trade[which(trade$t==year),]; trade = trade[order(trade$exporter),];
trade <- subset(trade,select=-c(number,unknown,t,exporter,importer,log_gdp_exp,log_gdp_imp,log_distance,polity_exp,polity_imp,cc))
colnames(trade) <- c("from","to","weight")
# Read Attributes Data
node.attr <- read.csv("data/TradeAttributes.csv", header = TRUE)
# generate Adjacency and Weight Matrices
N <- max(c(trade$from,trade$to)); W = matrix(0,N,N)
for (i in 1:dim(trade)[1]){ W[trade$from[i],trade$to[i]] = trade$weight[i] }
for(i in 1:N){
for(j in i:N){
if(j>i){
W[i,j] <- W[i,j] + W[j,i]
W[j,i] <- W[i,j]
}
}
}
# extract maximum connected component
TradeAdj <- matrix(as.numeric(W >=quantile(W,0.50)), N, N)
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
conn.comp <- clusters(GTrade)
maximal.conn.comp <- which(conn.comp$membership==1)
TradeAdj <- TradeAdj[maximal.conn.comp,maximal.conn.comp]
node.attr <- node.attr[maximal.conn.comp,]
diag(TradeAdj) <- 0
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
name <- as.character(node.attr$country)
K.max <- 6
Trade.Para.hat <- Est.DCSBM(TradeAdj,K.max)
vertices <- data.frame(name=name,n=c(1:N))%>%
mutate(group = Trade.Para.hat$e.hat) %>%
mutate(group = as.numeric(factor(group,
levels=sort(summary(as.factor(group)),index.return=TRUE,decreasing=T)$ix,
order=TRUE)))%>%
arrange(group,desc(n))%>%
mutate(name=factor(name,name))
TradeAdj <- TradeAdj[vertices$n,vertices$n]
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
V(GTrade)$name <- vertices$name
# ggplot
mycolor <- wes_palette('Darjeeling1',max(vertices$group),type="continuous")
mycolor <- sample(mycolor,length(mycolor))
ggraph(GTrade,layout='fr')+
geom_edge_link(edge_colour='black',edge_alpha=0.2,edge_width=0.3)+
geom_node_point(aes(size=N,color=as.factor(vertices$group)),shape=19,alpha=0.9)+
scale_size_continuous(range = c(0.5,10))+
scale_fill_manual(values=mycolor)+
geom_node_text(aes(label=as.character(name)),size=3,color='black')+
expand_limits(x=c(-1.2,1.2),y=c(-1.2,1.2))+
theme_minimal()+
theme(legend.position = 'none',
panel.grid = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
axis.title = element_blank())
ggraph(GTrade,layout='fr')+
geom_edge_link(edge_colour='black',edge_alpha=0.2,edge_width=0.3)+
geom_node_point(aes(size=N,color=as.factor(vertices$group)),shape=19,alpha=0.9)+
scale_size_continuous(range = c(0.5,10))+
scale_fill_manual(values=mycolor)+
geom_node_text(aes(label=as.character(name)),size=3,color='black')+
expand_limits(x=c(-1.2,1.2),y=c(-1.2,1.2))+
theme_minimal()+
theme(legend.position = 'none',
panel.grid = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
axis.title = element_blank())
ggraph(GTrade,layout='fr')+
geom_edge_link(edge_colour='black',edge_alpha=0.2,edge_width=0.3)+
geom_node_point(aes(size=N,color=as.factor(vertices$group)),shape=19,alpha=0.9)+
scale_size_continuous(range = c(0.5,10))+
scale_fill_manual(values=mycolor)+
geom_node_text(aes(label=as.character(name)),size=3,color='black')+
expand_limits(x=c(-1.2,1.2),y=c(-1.2,1.2))+
theme_minimal()+
theme(legend.position = 'none',
panel.grid = element_blank(),
axis.line = element_blank(),
axis.ticks = element_blank(),
axis.text = element_blank(),
axis.title = element_blank())
# Real data
library(R.matlab)
library(Matrix)
library(MASS)
library(tidyverse)
library(ggplot2)
library(gtools)
library(igraph)
library(ggraph)
#library(qgraph)
library(colormap)
library(wesanderson)
source("../R_SBM/fun_SBM.R")
source("../R_DCSBM/fun_DCSBM.R")
source("../R_DCSBM/Competitors_DCSBM.R")
# 1. Trade
#Read Edge Data from Trade.csv file
trade <- read.csv("data/Trade.csv", header = TRUE)
year <- 15
trade <- trade[which(trade$t==year),]; trade = trade[order(trade$exporter),];
trade <- subset(trade,select=-c(number,unknown,t,exporter,importer,log_gdp_exp,log_gdp_imp,log_distance,polity_exp,polity_imp,cc))
colnames(trade) <- c("from","to","weight")
# Read Attributes Data
node.attr <- read.csv("data/TradeAttributes.csv", header = TRUE)
# generate Adjacency and Weight Matrices
N <- max(c(trade$from,trade$to)); W = matrix(0,N,N)
for (i in 1:dim(trade)[1]){ W[trade$from[i],trade$to[i]] = trade$weight[i] }
for(i in 1:N){
for(j in i:N){
if(j>i){
W[i,j] <- W[i,j] + W[j,i]
W[j,i] <- W[i,j]
}
}
}
# extract maximum connected component
TradeAdj <- matrix(as.numeric(W >=quantile(W,0.50)), N, N)
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
conn.comp <- clusters(GTrade)
maximal.conn.comp <- which(conn.comp$membership==1)
TradeAdj <- TradeAdj[maximal.conn.comp,maximal.conn.comp]
node.attr <- node.attr[maximal.conn.comp,]
diag(TradeAdj) <- 0
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
name <- as.character(node.attr$country)
#V(GTrade)$name <- as.character(node.attr$country)
#V(GTrade)$name
#save(Trade.Para.hat,file="result/Trade.Para.hat.Rda")
load("result/Trade.Para.hat.Rda")
vertices <- data.frame(name=name,n=c(1:N))%>%
mutate(group = Trade.Para.hat$e.hat) %>%
mutate(group = as.numeric(factor(group,
levels=sort(summary(as.factor(group)),index.return=TRUE,decreasing=T)$ix,
order=TRUE)))%>%
arrange(group,desc(n))%>%
mutate(name=factor(name,name))
TradeAdj <- TradeAdj[vertices$n,vertices$n]
GTrade <- graph.adjacency(TradeAdj, mode="undirected")
V(GTrade)$name <- vertices$name
V(GTrade)$name[Trade.Para.hat$e.hat==1]
V(GTrade)$name[Trade.Para.hat$e.hat==2]
V(GTrade)$name[Trade.Para.hat$e.hat==3]
21+15+22
n1<- V(GTrade)$name[Trade.Para.hat$e.hat==1]
